#summary 解释器的架构
#labels Featured,Phase-Implementation
这个文件描述了解释器的一个通用架构. L0,L1,L2 三个语言的解释器都基本遵循这个架构.

= 词法分析 =
使用[http://www.dabeaz.com/ply/ PLY]工具中lex 工具.
根据词法定义将语言源文件分析成Token,供词法分析处理.

= 语法分析 =
使用[http://www.dabeaz.com/ply/ PLY]工具中yacc 工具.
这里将检查输入是否符合语言的语法定义，如果符合将通过生成抽象语法树.
这里的逻辑很简单就是将线性的输入转化成树状的AST.

= 语义分析 =
== 声明处理 ==
这一步在抽象语法树的基础上,分析程序结构.处理程序的"声明"部分.
  * 类型定义
  * 函数定义
  * 常量/变量定义等等.
  * 类定义等等

在这一步我们将建立起名字空间,这是下面的工作执行的基础.

== 静态语义检查 ==
这个阶段我们将检查程序是否符合语言定义的静态语义.
主要是类型是否匹配，名字是否正确等等.
详细内容见 StaticSemantic

= 解释执行 =
在抽象语法树上执行程序.
包含表达式计算引擎,流程控制处理,名字空间维护等等功能.

= 错误处理 =
错误处理贯穿了整个解释器工作流程的各个部分.
解释器的错误处理分为三块.
  * 词法分析部分 对于非法字符,简单的抛弃并报错
  * 语法分析部分 对于不符合语法规则的情况,立即报错。并停止分析.
  * 语义错误  目前没有静态语义检查.在运行时发现语义错误(比如类型错误等等),抛出异常，打印调用栈，错误位置并终止程序.

错误处理输出的信息包含以下内容:
  * 发生错误的位置 (至少定位到行)
  * 如果是语义错误, 打印调用栈.
  * 给出适当,详细,有用的错误信息.

