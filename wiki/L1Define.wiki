#summary L1语言定义
#labels Featured,Phase-Design

L1 (也被称为 SmallC) 语言的定义

L1 是一个相对完整的高级语言,拥有如下特性:
  * 基本类型 和 数组，类(结构体)组合类型
  * 支持条件分支和循环语句
  * 支持函数 和 递归函数调用
下面将对语言的各个部分进行介绍, 包括
  * 语法 
  * 语义 语义部分说明L1语言的静态语义和动态语义， 主要的描述是算法语义,也就是怎样实现. 

= BNF文法 =
{{{
(1) <prog> ::= {<classdecl>}[<condecl>][<vdecl>] <fdef>{<fdef>}
(2) <classdecl> ::= 'class' id '{' <decllist> '}'
(3) <decllist> ::= <decl>{ ';' <decl>}
(4) <decl> ::= <type> <idlist>
(5) <type> ::= id {'[]'}
(6) <idlist> ::= id {',' id }
(7) <condecl> ::= 'const' <condef>{ ',' <condef>} ';'
(8) <condef> ::= id '=' [ '-' ] num
(9) <vdecl> ::= 'var' <decllist> 'end'
(10) <fdef> ::= 'func' <type> <head> '{' [<vdecl>]<stlist> '}'
(11) <head> ::=id '('[<paralist>]')'
(12) <paralist> ::= <paradecl>{','<paradecl>}
(13) <paradecl> ::= <type> id
(14) <stlist>::= <st>{';'<st>}
(15) <st>::= <exp> | <cond> | <loop>
(16) <cond> ::= 'if' '(' <exp> ')' <st>[ 'else' <st>]
(17) <loop> ::= 'while' '(' <exp> ')' [<st>]
(18) <exp> ::= <orexp>[ '=' <orexp>]
(19) <orexp> ::= <andexp>{ '||' <andexp>}
(20) <andexp> ::= <relexp>{ '&&' <relexp>}
(21) <relexp> ::= <term>[<relop> <term>]
(22) <relop> ::= '==' | '!=' | '<' | '>' | '<=' | '>='
(23) <term> ::= <factor>{<addop> <factor>}
(24) <addop> ::= '+' | '-'
(25) <factor> ::= <uniexp>{<multop> <uniexp>}
(26) <multop> ::= '*' | '/' | '%'
(27) <uniexp> ::= {<uniop>}<postexp>
(28) <uniop> ::= '-' | '!' | '++' | '--' | 'chk'
(29) <postexp> ::= <entity>{<postfix>}
(30) <postfix> ::= '++' | '--' | <apara> | <sub> | <aselect> | <tcast>
(31) <apara> ::= '(' [<exp>{ ',' <exp>}] ')'
(32) <sub> ::= '[' <exp> ']'
(33) <aselect> ::= '.' id
(34) <tcast> ::= ':' <type>
(35) <entity> ::= id | num |<cast> | <alloc> | '?'
(36)<cast> ::= '('<stlist>')'
(37)<alloc> ::= 'new' <type> [ '[' <exp> ']' ]
}}}

= 抽象语法 = 
TODO

= 语言模型 = 
语言模型是指在解释器中表达源语言的各种语言要素的数据结构.比如如何表示类型，如何表示函数等等. 
这部分内容在论述语言的静态和动态语义的时候都会用到.

== 类型 ==
每一类型都将定义一个类，这个类包含有如下要素:
  * 名字
  * do_type_trans(self, op_name, arg = None) 这个函数是静态类型检查和计算接口. 这个函数体现了上面表格中的所有内容.
  * op_xxx 对于该类型支持每一个操作,都有一个对应的op_开头的函数. (比如op_assign, op_index 等等)
对于二元操作符的原型是 op_binop(self, lhs, rhs) 对于一元操作符的原型是 op_uniop(self, obj)
这些函数的实现蕴含了动态语义, 比如op_add 就会执行加法.
  * 内存分配接口 alloc_one

== 值 ==
一个值都有两个属性
  * 类型  
  * 实际的内部表示值 
比如一个 L1 的 int 型值12 的表示方式就会是:
  
  type -> intType  (其中intType = Integer())
  value -> 12

值可能是可变的(变量)或者是不可变的(常量).
L1语言中的常量只有一个隐式的类型int型,实现中将常量作为一种特殊的变量处理.
由于将具体的操作符的语义都在类型中定义了,变量值实现了一个代理方法
  op(self, op, arg)

通过调用类型的相关函数来实现运算. 

下面这个图列出这些概念,并说明了它们之间的关系

http://finterpretor.googlecode.com/svn/wiki/L1Types.png

== 名字和名字空间,作用域 ==
名字空间保存 名字 -> 值 对, 是对字典(哈希表)的简单封装.
名字空间提供查询和设置接口.
  * 查询 get 查询名字对应的值, 可能是类型,函数，或者 变量，常量  
  * 设置 set 设置名字对应的值, 可能是类型,函数 - 声明处理阶段，或者 变量，常量 - 解释执行阶段  

L1 采用静态作用域，由于不支持函数的嵌套定义, 只有一个全局作用域 和 (函数)局部作用域.
全局作用域包含
  * 全局的常量,变量
  * 函数
  * 类
  * 预定义的其他名字

(函数)局部作用域包含
  * 函数的参数
  * 函数的局部变量
在函数中进行名字查找时,先查找局部定义域,找不到时查找全局作用域.

== 函数 ==
实现中将函数作为名字空间的子类实现.
函数有如下要素:
  * 参数类型表  params_type 
  * 参数名称表  params 
  * 返回值类型  ret_type
  * 调用接口 call 方法
  * 函数局部名字空间 ns 包括参数和局部变量
  * 函数体

http://finterpretor.googlecode.com/svn/wiki/L1NsFunction.png

= 静态语义 = 
下面内容属于静态语义范畴
  * 类型
  * 操作符的类型约束
  * 名字解析
  * 作用域 

== 类型和操作符 ==
L1 语言支持如下基本类型:
  * int 整形
  * void 不存在这个类型的对象
  * nulltype 可能值只有一个特殊的null

L1 语言支持如下的组合类型:
  * array 数组 数组元素类型可以是任何合法的L1类型，但是各个元素类型必须一致
  * class 类 (类似C结构体，只有数据成员,但是赋值行为上像java)

L1 语言支持如下操作符

|| 名称 	|| 操作符 	|| 优先级 || 结合性 || 说明 ||
|| 赋值 	|| =      	|| 0      || 左     ||      || 
|| 逻辑或 	|| `|``|`	|| 1      || 左     ||      ||
|| 逻辑与 	|| &&     	|| 2      || 左     ||      ||
|| 关系1 	|| == !=  	|| 3      || 左     ||      ||
|| 关系2 	|| < <= > >=|| 3      || 左     ||      ||
|| 加减 	|| + -   	|| 4      || 左     ||      ||
|| 乘除 	|| `* / %` 	|| 5      || 左     ||      ||
|| 前缀单目 || - ! ++ --|| 6  	  || 右     ||      ||
|| 异常处理 || chk   	|| 6      || 右     ||      ||
|| 后缀1    || ++ --   	|| 7      || 左     ||      ||
|| 后缀2    || []   	|| 7      || 左     || 数组下标操作||
|| 后缀3    || .    	|| 7      || 左     || 类成员操作||
|| 后缀3    || ()    	|| 8      || 左     || 函数调用||
|| 括号     || ()    	|| 9      || 左     || ||

说明: 以上表格中的优先级和结合性信息实际上属于语法的范畴，并且这些信息已经蕴含在上面的产生式中.


操作符及其对应的类型约束是L1语言静态语义的主要部分.

为了行文方便，对下面内容的一些标记做如下几个约定:
  # SAME_TYPE 表示该操作的主要操作数的类型(也就是当前论述的类型一致)
  # "实现用标识符"是操作符的内部表示
  # 类型的静态语义(主要是类型约束)将通过表格形式列出. 
 

下面将对每一个类型论述其支持的操作.
=== void ===
基本类型
不支持任何操作符

=== nullType ===
基本类型 
null值的类型, 在语法中没有关键字表示这个类型，这个类型的值有且只有一个null
支持的操作符如下表所列

|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| == 		|| eq	 		|| 类类型或者nullType 	|| int 			|| 类类型表示任意一个class类型||  
|| != 		|| ne	 		|| 类类型或者nullType	|| int 			|| 		||  
  

=== int ===
基本类型
支持的操作符如下表所列

|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| int 			|| int 			|| 		||  
|| `|``|`	|| or 			|| int 			|| int 			|| 		||  
|| && 		|| and	 		|| int 			|| int 			|| 		||  
|| == 		|| eq	 		|| int 			|| int 			|| 		||  
|| != 		|| ne	 		|| int 			|| int 			|| 		||  
|| < 		|| lt	 		|| int 			|| int 			|| 		||  
|| <= 		|| le	 		|| int 			|| int 			|| 		||  
|| > 		|| gt	 		|| int 			|| int 			|| 		||  
|| >= 		|| ge	 		|| int 			|| int 			|| 		||  
|| + 		|| add	 		|| int 			|| int 			|| 		||  
|| - 		|| minus 		|| int 			|| int 			|| 		||  
|| `*` 		|| mul	 		|| int 			|| int 			|| 		||  
|| / 		|| div	 		|| int 			|| int 			|| 		||  
|| % 		|| mod	 		|| int 			|| int 			|| 		||  
|| - 		|| minus_		|| - 			|| int 			|| 负号 ||  
|| ! 		|| not			|| - 			|| int 			|| 		||  
|| chk 		|| chk			|| - 			|| int 			|| 		||  
|| ++ 		|| inc			|| - 			|| int 			|| 前缀	||  
|| ++ 		|| inc_			|| - 			|| int 			|| 后缀	||  
|| -- 		|| dec			|| - 			|| int 			|| 前缀	||  
|| -- 		|| dec_			|| - 			|| int 			|| 后缀	||  

===数组(array)===
组合类型
数组类型需要记录数组元素的类型,用base这个成员记录
支持的操作符如下表所列

|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| SAME_TYPE	|| SAME_TYPE	|| 		||  
|| == 		|| eq	 		|| SAME_TYPE 	|| int 			|| 		||  
|| != 		|| ne	 		|| SAME_TYPE	|| int 			|| 		||  
|| [] 		|| index 		|| int 			|| base     	|| 		||  

数组类型需要记录

===类(class)===
组合类型
class 类型需要记录成员的名字和类型,这些信息通过一个字典记录在members 这个成员变量中.
支持的操作符如下表所列

|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| SAME_TYPE 或者 nullType	|| SAME_TYPE	|| 		||  
|| == 		|| eq	 		|| SAME_TYPE 或者 nullType 	|| int 			|| 		||  
|| != 		|| ne	 		|| SAME_TYPE 或者 nullType	|| int 			|| 		||  
|| . 		|| member 		|| string || 根据class具体定义决定,members[extra_arg]|| 注意这里的附加参数类型 string 实际上并不是L1语言的类型||  

上面阐述了各个类型支持的操作符及其类型约束条件, 下面描述在解释器实现中怎样表达这些语义。(算法语义)

对于每一类类型定义一个类， 该类的对象在解释器中表达源语义的类型.
比如对于源语言的int类型,定义一个类Integer , 并实例化一个对象intType 表示 源语言的int.
比如对于源语言的数组,定义一个类Array , 对于整形数组int[], 用 Array 的实例 Array(intType) 表示.
同时注意它们有一个共同的基类Type，其中定义了一些公共的函数, 比如定义了两个类型相等的含义.
{{{
class Type(object):
    def __eq__(self,rhs):
        return self.name == rhs.name

    def __ne__(self,rhs):
        return not self.__eq__(rhs)

}}}
可以看到，L1 语言类型比较方法也仅仅是名字的比较.

这样的类跟静态语义有关的内容有:
  * name 类的名字 
  * do_type_trans(self, op_name, arg = None) 这个函数是静态类型检查和计算接口. 这个函数体现了上面表格中的所有内容.

下面的代码片段是一个例子, 是L1中Class的实现:
{{{
class Struct(Type):

    def __init__(self,name):
        self.name = name
        self.members = {}

    def do_type_trans(self, op_name, arg = None):
        '''检查类型匹配，并根据操作符返回对应的类型 不匹配时返回 None'''
        if op_name in ('eq', 'ne'):
            if (arg == self or arg == nullType):
                return intType
            else:
                return None
        elif op_name == "assign":
            if (arg == self or arg == nullType):
                return self
            else:
                return None
        elif op_name == "member":
            if arg in self.members:
                return self.members[arg]
            else:
                return None
        return super(Struct,self).do_type_trans(op_name, arg)

}}}
可以看到do_type_trans 函数进行了类型检查并返回了操作结果的类型.

== 名字和作用域 ==
L1 语言是静态作用域的, 也就是一个名字是否可见在静态检查时就可以确定.


