#summary L1语言定义
#labels Featured,Phase-Design

L1 (aka SmallC) 语言的定义

= 语法 =
{{{
(1) <prog> ::= {<classdecl>}[<condecl>][<vdecl>] <fdef>{<fdef>}
(2) <classdecl> ::= 'class' id '{' <decllist> '}'
(3) <decllist> ::= <decl>{ ';' <decl>}
(4) <decl> ::= <type> <idlist>
(5) <type> ::= id {'[]'}
(6) <idlist> ::= id {',' id }
(7) <condecl> ::= 'const' <condef>{ ',' <condef>} ';'
(8) <condef> ::= id '=' [ '-' ] num
(9) <vdecl> ::= 'var' <decllist> 'end'
(10) <fdef> ::= 'func' <type> <head> '{' [<vdecl>]<stlist> '}'
(11) <head> ::=id '('[<paralist>]')'
(12) <paralist> ::= <paradecl>{','<paradecl>}
(13) <paradecl> ::= <type> id
(14) <stlist>::= <st>{';'<st>}
(15) <st>::= <exp> | <cond> | <loop>
(16) <cond> ::= 'if' '(' <exp> ')' <st>[ 'else' <st>]
(17) <loop> ::= 'while' '(' <exp> ')' [<st>]
(18) <exp> ::= <orexp>[ '=' <orexp>]
(19) <orexp> ::= <andexp>{ '||' <andexp>}
(20) <andexp> ::= <relexp>{ '&&' <relexp>}
(21) <relexp> ::= <term>[<relop> <term>]
(22) <relop> ::= '==' | '!=' | '<' | '>' | '<=' | '>='
(23) <term> ::= <factor>{<addop> <factor>}
(24) <addop> ::= '+' | '-'
(25) <factor> ::= <uniexp>{<multop> <uniexp>}
(26) <multop> ::= '*' | '/' | '%'
(27) <uniexp> ::= {<uniop>}<postexp>
(28) <uniop> ::= '-' | '!' | '++' | '--' | 'chk'
(29) <postexp> ::= <entity>{<postfix>}
(30) <postfix> ::= '++' | '--' | <apara> | <sub> | <aselect> | <tcast>
(31) <apara> ::= '(' [<exp>{ ',' <exp>}] ')'
(32) <sub> ::= '[' <exp> ']'
(33) <aselect> ::= '.' id
(34) <tcast> ::= ':' <type>
(35) <entity> ::= id | num |<cast> | <alloc> | '?'
(36)<cast> ::= '('<stlist>')'
(37)<alloc> ::= 'new' <type> [ '[' <exp> ']' ]
}}}

= 静态语义 =

== 类型系统 ==
L1 语言支持如下基本类型:
  * int 整形
  * void 不存在这个类型的对象
  * nulltype 可能值只有一个特殊的null

支持如下的组合类型:
  * array 数组 数组元素类型可以是任何合法的L1类型，但是各个元素类型必须一致
  * class 结构体 类似C 的结构体

== 操作符/运算符 ==

===操作符分组列表===
|| 名称 	|| 操作符 	|| 优先级 || 结合性 || 说明 ||
|| 赋值 	|| =      	|| 0      || 左     ||      || 
|| 逻辑或 	|| | |		|| 1      || 左     ||      ||
|| 逻辑与 	|| &&     	|| 2      || 左     ||      ||
|| 关系1 	|| == !=  	|| 3      || 左     ||      ||
|| 关系2 	|| < <= > >=|| 3      || 左     ||      ||
|| 加减 	|| + -   	|| 4      || 左     ||      ||
|| 乘除 	|| * / %   	|| 5      || 左     ||      ||
|| 前缀单目 || - ! ++ --|| 6  	  || 右     ||      ||
|| 异常处理 || chk   	|| 6      || 右     ||      ||
|| 后缀1    || ++ --   	|| 7      || 左     ||      ||
|| 后缀2    || []   	|| 7      || 左     || 数组下标操作||
|| 后缀3    || .    	|| 7      || 左     || 类成员操作||
|| 后缀3    || ()    	|| 8      || 左     || 函数调用||
|| 括号     || ()    	|| 9      || 左     || ||
说明: 以上表格中的优先级和结合性信息实际上属于语法的范畴，并且这些信息已经蕴含在上面的产生式中.

===类型的语义和实现===
下面将对每一个类型论述其静态,动态语义,同时给出对应的实现的方法.
为了行文方便，做如下几个约定:
  #SAME_TYPE 表示该操作的主要操作数的类型(也就是当前论述的类型一致)
  
  * void 基本类型
    不支持任何操作符
  * nullType 基本类型 
    null值的类型, 在语法中没有标识符表示这个类型，这个类型的值有且只有一个null
	支持的操作符如下表所列
|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| == 		|| eq	 		|| 类类型或者nullType 	|| int 			|| 类类型表示任意一个class类型||  
|| != 		|| ne	 		|| 类类型或者nullType	|| int 			|| 		||  
  * int 基本类型
	支持的操作符如下表所列
|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| int 			|| int 			|| 		||  
|| | |		|| or 			|| int 			|| int 			|| 		||  
|| && 		|| and	 		|| int 			|| int 			|| 		||  
|| == 		|| eq	 		|| int 			|| int 			|| 		||  
|| != 		|| ne	 		|| int 			|| int 			|| 		||  
|| < 		|| lt	 		|| int 			|| int 			|| 		||  
|| <= 		|| le	 		|| int 			|| int 			|| 		||  
|| > 		|| gt	 		|| int 			|| int 			|| 		||  
|| >= 		|| ge	 		|| int 			|| int 			|| 		||  
|| + 		|| add	 		|| int 			|| int 			|| 		||  
|| - 		|| minus 		|| int 			|| int 			|| 		||  
|| * 		|| mul	 		|| int 			|| int 			|| 		||  
|| / 		|| div	 		|| int 			|| int 			|| 		||  
|| % 		|| mod	 		|| int 			|| int 			|| 		||  
|| - 		|| minus_		|| - 			|| int 			|| 负号 ||  
|| ! 		|| not			|| - 			|| int 			|| 		||  
|| chk 		|| chk			|| - 			|| int 			|| 		||  
|| ++ 		|| inc			|| - 			|| int 			|| 前缀	||  
|| ++ 		|| inc_			|| - 			|| int 			|| 后缀	||  
|| -- 		|| dec			|| - 			|| int 			|| 前缀	||  
|| -- 		|| dec_			|| - 			|| int 			|| 后缀	||  
  * 数组(array) 组合类型
    数组元素类型用base_type表示
	支持的操作符如下表所列
|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| SAME_TYPE	|| SAME_TYPE	|| 		||  
|| == 		|| eq	 		|| SAME_TYPE 	|| int 			|| 		||  
|| != 		|| ne	 		|| SAME_TYPE	|| int 			|| 		||  
|| [] 		|| index 		|| int 			|| base_type	|| 		||  
  * 类(class) 组合类型
	支持的操作符如下表所列
|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| SAME_TYPE 或者 nullType	|| SAME_TYPE	|| 		||  
|| == 		|| eq	 		|| SAME_TYPE 或者 nullType 	|| int 			|| 		||  
|| != 		|| ne	 		|| SAME_TYPE 或者 nullType	|| int 			|| 		||  
|| . 		|| member 		|| string		|| 根据class具体定义决定|| 注意这里的附加参数类型 string 实际上并不是L1语言的类型||  

上面阐述了各个类型支持的操作符及其类型约束条件,具体的语义将被蕴含在实现中. 下面介绍具体的实现细节.
每一个类型都有一个对应的类，定义了如下方法
  # do_type_trans(self, op_name, arg = None) 这个函数是静态类型检查和计算接口.
    这个函数体现了上面表格中的所有内容.
  # op_xxx 对于该类型支持每一个操作,都有一个对应的op_开头的函数. (比如op_assign, op_index 等等)
    对于二元操作符的原型是 op_binop(self, lhs, rhs) 对于一元操作符的原型是 op_uniop(self, obj)

下面是Integer 类型的实现的代码片段. 
{{{
class Integer(Type):
    '''Small C 整数类型'''


}}}
= 流程控制 =
L1 支持条件和循环结构
具体语法见上面的语法定义

= 函数 =
L1 支持函数定义和调用
  * 参数定义 同C语言一样,不过不支持默认参数
  * 返回值   没有return 语句, 将函数中最后一个语句的值作为返回值.
  * 调用     函数调用语法同C语言一样

L1 语言的入口函数是 main , main函数一般是一个无参并返回void 的函数

