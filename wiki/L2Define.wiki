#summary L2语言定义
#labels Featured,Phase-Design

L2 (也被称为 OOC) 语言的定义

L2 语言一个简单的面向对象的语言. 有如下特性:
  * 支持基本类型,数组类型 和 类
  * 支持条件 循环等流程控制语句 (参考L1Define)
  * 有私有 公有等访问控制特性
  * 有继承 多态等特性
  * 有抽象方法的概念
这个语言是一个相对完整的面向对象的语言. 

= 语法 =
{{{
(1) <prog> ::= <classdecl>{<classdecl>}
(2) <classdecl> ::= 'class' [ 'abstract' ] id [ ':' id ] '{' [<condecl>][ 'static' <memebr>] [ 'private' <member>] [ 'public' <member>] [ 'redef' {<cfdef>}] '}'
(3) <condecl> ::= 'const' <condef>{ ',' <condef>} ';'
(4) <condef> ::= id '=' [ '-' ] num
(5) <member> ::= [<vdecl>]{<fdef>}
(6) <vdecl> ::= 'var' <decllist> 'end'
(7) <decllist> ::= <decl>{ ';' <decl>}
(8) <decl> ::= <type> <idlist>
(9) <type> ::= id {'[]'}
(10) <idlist> ::= id {',' id }
(11) <fdef> ::= <afdef> | <cfdef>
(12) <afdef> ::= 'func' 'abstract' <type> id '(' [<type> {','<type>}] ')'
(13) <cfdef> ::= 'func' <type> <head> '{' [<vdecl>]<stlist> '}'
(14) <head> ::=id '('[<paralist>]')'
(15) <stlist>::= <st>{';'<st>}
(16) <paralist> ::= <paradecl>{','<paradecl>}
(17) <st>::= <exp> | <cond> | <loop>
(18) <paradecl> ::= <type> id
(19) <cond> ::= 'if' '(' <exp> ')' <st>[ 'else' <st>]
(20) <loop> ::= 'while' '(' <exp> ')' [<st>]
(21) <exp> ::= <orexp>[ '=' <orexp>]
(22) <orexp> ::= <andexp>{ '||' <andexp>}
(23) <andexp> ::= <relexp>{ '&&' <relexp>}
(24) <relexp> ::= <term>[<relop> <term>]
(25) <relop> ::= '==' | '!=' | '<' | '>' | '<=' | '>='
(26) <term> ::= <factor>{<addop> <factor>}
(27) <addop> ::= '+' | '-'
(28) <factor> ::= <uniexp>{<multop> <uniexp>}
(29) <multop> ::= '*' | '/' | '%'
(30) <uniexp> ::= {<uniop>}<postexp>
(31) <uniop> ::= '-' | '!' | '++' | '--' | 'chk'
(32) <postexp> ::= <entity>{<postfix>}
(33) <postfix> ::= '++' | '--' | <apara> | <index> | <aselect> | <tcast>
(34) <apara> ::= '(' [<exp>{ ',' <exp>}] ')'
(35) <index> ::= '[' <exp> ']'
(36) <aselect> ::= '.' id
(37) <tcast> ::= ':' <type>
(38) <entity> ::= id | num | <cast> | <alloc>
(39) <cast> ::= '('<stlist>')'
(40) <alloc> ::= 'new' <type> [ '[' <exp> ']' ]
}}}

= 类型系统 =
L2 语言支持如下基本类型:
  * int 整形  默认值为0
  * void 不存在这个类型的对象
  * nulltype 可能值只有一个特殊的null

支持如下的组合类型:
  * array 数组 数组元素类型可以是任何合法的L1类型，但是各个元素类型必须一致
  * class 类 类似Java 的class. 所有类都是Object 类的子类. 也就是说L2语言也是一个单根的语言


== 操作符/运算符 ==
大部分都可以参考L1语言相关部分.
不过对于数组类型和类类型需要有一些不同的地方.
===数组(array)===
组合类型
数组元素类型用base_type表示
支持的操作符如下表所列

|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| SAME_TYPE	|| SAME_TYPE	|| 		||  
|| == 		|| eq	 		|| SAME_TYPE 	|| int 			|| 		||  
|| != 		|| ne	 		|| SAME_TYPE	|| int 			|| 		||  
|| [] 		|| index 		|| int 			|| base_type	|| 		||  
|| .        || member       || "length"     || int          || 数组支持array.length 这样的操作 ||

===类(class)===
组合类型
支持的操作符如下表所列
SUB_CLASS 表示该类的子类(派生类)
BASE_CLASS 表示该类的父类(基类)
|| 操作符 	|| 实现用标识符 || 附加参数类型 || 操作结果类型 || 备注 ||  
|| = 		|| assign 		|| SAME_TYPE 或者 SUB_CLASS 或者 nullType 	|| SAME_TYPE	|| 		||  
|| == 		|| eq	 		|| SAME_TYPE 或者 BASE_CLASS 或者 或者SUB_CLASS 或者 nullType 	|| int 			|| 		||  
|| != 		|| ne	 		|| SAME_TYPE 或者 BASE_CLASS 或者 或者SUB_CLASS 或者 nullType 	|| int 			|| 		||  
|| . 		|| member 		|| string		|| 根据class具体定义决定|| 注意这里的附加参数类型 string 实际上并不是L2语言的类型||  

注意这里的.(member)操作符返回的不仅可能返回数据,而且也可能返回函数等语言元素了.

= 语言模型 = 
TODO:什么是语言模型？

== 类型 == 
参考L1的相关部分,模型是一致.
只是类型多了几个.

== 值 ==
参考L1的相关部分,同L1是完全一致的.

下面这个图列出这些概念,并说明了它们之间的关系

http://finterpretor.googlecode.com/svn/wiki/L2Types.png

== 类 == 
L2 是一个面向对象的语言,类是组成L2程序的基本成分.

== 类的组成成分 == 
一个类包含如下内容:
  * 常量  修饰符为const 使用说明同static 变量一致，但是值不能更改 
  * 变量  可能的修饰符为 
      * public  能在本类和子类非static成员函数内部访问 也可以通过obj.var_name这种形式访问 
      * static  能在本类和子类成员函数内部访问 也可以通过class_name.var_name 或者 obj.var_name这种形式访问 
      * private 只能本类在非static 方法内部访问  子类的方法不能访问
  * 方法  可能的修饰符有
      * abstract 未实现的,子类需要覆盖abstract 方法
      * static 静态方法  只能访问类属性和其他静态方法. 能在本类和子类成员函数内部访问 也可以通过class_name.var_name 或者 obj.var_name这种形式访问 
      * public 公有方法  能在本类和子类非static成员函数内部访问 也可以通过class_name.method_name 或者 obj.method_name这种形式访问 
      * private 私有方法 只能本类非static 方法内部调用  子类的方法不能调用
      * redef 重新定义的方法(基类必须有同名公有方法) 

L2语言类的成员修饰符有const static abstract public private redef 这几个, 下面的表格列出了它们的含义.
注意L2 语言每个成员的修饰符只能有一个,而不像C++那样可以重叠. 

|| 修饰符 	|| 访问性 	|| 静态性 		|| 适用于 		||
|| abstract || public 	|| non-static 	|| 方法			||
|| public   || public 	|| non-static 	|| 方法 变量	||
|| private  || private 	|| non-static 	|| 方法 变量	||
|| static   || public 	|| static 		|| 方法 变量	||
|| redef    || public 	|| non-static	|| 方法			||
|| const    || public 	|| static		|| 变量			||

== 继承 ==
L2语言的类支持单继承, 使用类似C++的语法
L2使用redef 修饰符来表示对子类方法的重定义.

L2 支持多态. (下面的伪代码对继承，重定义和多态进行了示意)
{{{
class A{
  public func int some_method()
  {
     //do something for A
	 print (1)
  }
}

class B:A{
  redef func int some_method(){}	
  {
     //do something different for B
	 print (2)
  }
}

//pseudocode 
A a = new A();
a.some_method(); //will print 1
a = new B();
a.some_method(); //will print 2 
}}}


== 名字和名字空间,作用域 ==
名字空间提供查询和设置接口.
  * 查询 get 查询名字对应的值, 可能是类型,函数，或者 变量，常量  
  * 设置 set 设置名字对应的值, 可能是类型,函数 - 声明处理阶段，或者 变量，常量 - 解释执行阶段  

L2程序由类组成, 有一个全局作用域,每一个类方法都有一个局部作用域.

全局作用域包含
  * 类
  * 预定义的其他名字

静态方法局部作用域包含
  * 方法的参数
  * 方法的局部变量
  * 类变量 (包括常量,变量, 静态方法)
名字查找顺序 参数,局部变量 -> 类变量  -> 全局名字空间

普通方法局部作用域包含
  * 方法的参数
  * 方法的局部变量
  * 类变量 (包括常量,变量, 静态方法)
  * 实例变量
  * this 变量
名字查找顺序 参数,局部变量 -> 实例变量 -> 类变量  -> 全局名字空间

